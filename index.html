<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
    <title>Slither Client</title>
    <style>
        :root {
            color-scheme: dark;
            font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #05070d;
            color: #e2e8f0;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            user-select: none;
        }

        .panel {
            position: fixed;
            backdrop-filter: blur(18px);
            background: rgba(8, 14, 24, 0.7);
            border: 1px solid rgba(94, 117, 151, 0.28);
            border-radius: 18px;
            padding: 18px 20px;
            box-shadow: 0 25px 60px rgba(2, 6, 12, 0.4);
        }

        #scorePanel {
            top: calc(24px + var(--safe-top));
            left: calc(24px + var(--safe-left));
            min-width: clamp(160px, 24vw, 220px);
            max-width: min(280px, 92vw);
        }

        #scorePanel .label {
            font-size: 13px;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.72);
        }

        #scoreValue {
            margin-top: 6px;
            font-size: clamp(32px, 7vw, 48px);
            font-weight: 700;
            color: #f8fafc;
        }

        #scoreMeta {
            margin-top: 8px;
            font-size: clamp(12px, 2.8vw, 14px);
            font-weight: 500;
            color: #94a3b8;
            line-height: 1.4;
        }

        #scorePanel .account {
            margin-top: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .account-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: clamp(13px, 3vw, 15px);
            font-weight: 600;
            color: #e2e8f0;
            background: rgba(12, 19, 31, 0.55);
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid rgba(59, 76, 103, 0.38);
        }

        .account-row .account-label {
            color: rgba(148, 163, 184, 0.82);
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .account-row .account-value {
            font-size: clamp(15px, 3.4vw, 18px);
            font-weight: 700;
            color: #f8fafc;
        }

        #cashoutControl {
            position: fixed;
            left: 50%;
            bottom: calc(100px + var(--safe-bottom));
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            z-index: 9;
            pointer-events: none;
        }

        @media (max-height: 700px) {
            #cashoutControl {
                bottom: calc(70px + var(--safe-bottom));
            }
        }

        .cashout-button {
            border: none;
            border-radius: 999px;
            padding: 10px 18px;
            font-size: clamp(12px, 2.8vw, 14px);
            font-weight: 600;
            color: #0f172a;
            background: linear-gradient(135deg, #fbbf24, #f97316);
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.2s ease;
            box-shadow: 0 12px 24px rgba(249, 115, 22, 0.35);
            pointer-events: auto;
        }

        .cashout-button:disabled,
        .cashout-button[aria-disabled="true"] {
            cursor: default;
            opacity: 0.45;
            box-shadow: none;
        }

        .cashout-button.holding {
            transform: translateY(1px) scale(0.99);
            box-shadow: 0 14px 28px rgba(249, 115, 22, 0.4);
        }

        .cashout-hint {
            font-size: clamp(11px, 2.6vw, 13px);
            color: rgba(148, 163, 184, 0.75);
            text-align: center;
        }

        #leaderboard {
            top: calc(24px + var(--safe-top));
            right: calc(24px + var(--safe-right));
            width: clamp(200px, 28vw, 240px);
        }

        #leaderboard .title {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.76);
            margin-bottom: 10px;
        }

        #leaderboardList {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #leaderboardList li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            color: #cbd5f5;
            background: rgba(12, 19, 31, 0.55);
            padding: 6px 10px;
            border-radius: 12px;
            border: 1px solid rgba(59, 76, 103, 0.4);
        }

        #leaderboardList li.me {
            background: rgba(37, 99, 235, 0.3);
            border-color: rgba(59, 130, 246, 0.45);
            color: #e2e8f0;
            box-shadow: 0 8px 18px rgba(37, 99, 235, 0.25);
        }

        #leaderboardList li .name {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #minimapPanel {
            position: fixed;
            bottom: calc(24px + var(--safe-bottom));
            right: calc(24px + var(--safe-right));
            width: clamp(188px, 26vw, 240px);
            padding: 16px;
        }

        #minimapPanel .title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.76);
            margin-bottom: 10px;
        }

        #minimapCanvas {
            display: block;
            width: clamp(164px, 22vw, 188px);
            height: clamp(164px, 22vw, 188px);
            border-radius: 16px;
            border: 1px solid rgba(59, 76, 103, 0.45);
            background: rgba(10, 16, 26, 0.65);
        }

        .overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 50% 35%, rgba(26, 45, 74, 0.22), rgba(5, 8, 12, 0.9));
            z-index: 10;
        }

        .overlay.hidden {
            display: none;
        }

        .card {
            background: rgba(8, 14, 24, 0.8);
            border-radius: 24px;
            padding: 32px 36px 36px;
            border: 1px solid rgba(59, 76, 103, 0.4);
            box-shadow: 0 30px 80px rgba(3, 6, 12, 0.55);
            text-align: center;
            width: min(420px, 90vw);
        }

        .card h2 {
            margin: 0 0 16px;
            font-size: 26px;
            font-weight: 700;
            color: #f8fafc;
        }

        .card p {
            margin: 0 0 20px;
            color: #94a3b8;
            font-size: 15px;
        }

        input[type="text"] {
            width: 100%;
            padding: 14px 16px;
            border-radius: 14px;
            border: 1px solid rgba(59, 76, 103, 0.5);
            background: rgba(10, 18, 30, 0.9);
            color: #e2e8f0;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 18px;
            outline: none;
            transition: border-color 0.2s ease;
        }

        input[type="text"]:focus {
            border-color: rgba(94, 234, 212, 0.6);
        }

        button.primary {
            width: 100%;
            padding: 14px 16px;
            border-radius: 16px;
            border: none;
            font-size: 17px;
            font-weight: 700;
            color: #020617;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            cursor: pointer;
            box-shadow: 0 12px 30px rgba(34, 197, 94, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            touch-action: manipulation;
        }

        button.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 38px rgba(34, 197, 94, 0.42);
        }

        button.primary:focus-visible {
            outline: 3px solid rgba(94, 234, 212, 0.6);
            outline-offset: 2px;
        }

        .skin-picker {
            margin-bottom: 22px;
        }

        .bet-control {
            margin-bottom: 22px;
            text-align: left;
        }

        .bet-control label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.75);
            margin-bottom: 8px;
        }

        .bet-control input[type="number"] {
            width: 100%;
            padding: 12px 14px;
            border-radius: 14px;
            border: 1px solid rgba(59, 76, 103, 0.5);
            background: rgba(10, 18, 30, 0.9);
            color: #e2e8f0;
            font-size: 16px;
            font-weight: 600;
            outline: none;
            appearance: textfield;
        }

        .bet-control input[type="number"]::-webkit-outer-spin-button,
        .bet-control input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .bet-control .bet-hint {
            margin-top: 6px;
            font-size: 13px;
            color: rgba(148, 163, 184, 0.78);
        }

        .skin-picker .caption {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.75);
        }

        .skin-picker .caption span:last-child {
            color: #e2e8f0;
            letter-spacing: 0;
        }

        .skin-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
        }

        .skin-option {
            position: relative;
            border: 2px solid transparent;
            border-radius: 999px;
            height: 40px;
            cursor: pointer;
            box-shadow: inset 0 0 10px rgba(15, 23, 42, 0.4);
            transition: transform 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
        }

        .skin-option::after {
            content: attr(data-name);
            position: absolute;
            inset: 6px 12px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.25);
            color: rgba(226, 232, 240, 0.8);
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .skin-option:hover::after {
            opacity: 1;
        }

        .skin-option.selected {
            border-color: rgba(255, 255, 255, 0.85);
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(148, 163, 184, 0.35);
        }

        .touch-controls {
            position: fixed;
            left: calc(16px + var(--safe-left));
            bottom: calc(16px + var(--safe-bottom));
            display: none;
            gap: 16px;
            align-items: flex-end;
            z-index: 8;
            pointer-events: none;
        }

        .touch-controls.active {
            display: flex;
        }

        .touch-controls > * {
            pointer-events: auto;
        }

        .joystick {
            position: relative;
            width: clamp(120px, 30vw, 160px);
            height: clamp(120px, 30vw, 160px);
            border-radius: 999px;
            background: rgba(8, 14, 24, 0.7);
            border: 1px solid rgba(94, 117, 151, 0.28);
            box-shadow: inset 0 18px 38px rgba(2, 6, 12, 0.55);
            touch-action: none;
        }

        .joystick::before {
            content: "";
            position: absolute;
            inset: 18%;
            border-radius: 999px;
            border: 1px solid rgba(59, 76, 103, 0.45);
            background: radial-gradient(circle, rgba(59, 76, 103, 0.35), rgba(15, 23, 42, 0.65));
        }

        .joystick-handle {
            position: absolute;
            width: clamp(48px, 16vw, 64px);
            height: clamp(48px, 16vw, 64px);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(59, 130, 246, 0.85), rgba(29, 78, 216, 0.9));
            border: 2px solid rgba(148, 163, 184, 0.4);
            box-shadow: 0 14px 30px rgba(29, 78, 216, 0.45);
            pointer-events: none;
        }

        .boost-button {
            border: none;
            border-radius: 999px;
            padding: 18px 26px;
            font-size: clamp(15px, 4vw, 18px);
            font-weight: 700;
            color: #020617;
            background: linear-gradient(135deg, #fb923c, #f97316);
            box-shadow: 0 18px 32px rgba(249, 115, 22, 0.35);
            cursor: pointer;
            touch-action: manipulation;
            transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.18s ease;
        }

        .boost-button:focus-visible {
            outline: 3px solid rgba(251, 191, 36, 0.55);
            outline-offset: 2px;
        }

        .boost-button.active {
            transform: translateY(-2px);
            box-shadow: 0 24px 42px rgba(249, 115, 22, 0.5);
        }

        .boost-button.disabled,
        .boost-button:disabled {
            cursor: default;
            opacity: 0.5;
            box-shadow: none;
        }

        body.is-touch #scorePanel {
            top: calc(16px + var(--safe-top));
            left: calc(16px + var(--safe-left));
            bottom: auto;
        }

        body.is-touch #leaderboard {
            top: calc(16px + var(--safe-top));
            right: calc(16px + var(--safe-right));
            bottom: auto;
        }

        body.is-touch #minimapPanel {
            bottom: calc(16px + var(--safe-bottom));
            right: calc(16px + var(--safe-right));
            left: auto;
            top: auto;
        }

        body.is-touch .touch-controls {
            display: flex;
        }

        #deathScreen .card {
            width: min(360px, 90vw);
        }

        #deathScreen .summary {
            font-size: 18px;
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 12px;
        }

        #deathScreen .score {
            font-size: 32px;
            font-weight: 700;
            color: #f1f5f9;
            margin-bottom: 24px;
        }

        #deathScreen .death-balance {
            font-size: 16px;
            font-weight: 500;
            color: #cbd5f5;
            margin-bottom: 18px;
        }

        #deathScreen .bet-control {
            margin-bottom: 16px;
        }

        #deathScreen .bet-control input[type="number"] {
            background: rgba(11, 18, 30, 0.92);
        }

        #deathScreen .bet-control .bet-hint {
            color: rgba(148, 163, 184, 0.82);
        }

        #deathScreen button {
            margin-top: 6px;
        }

        #cashoutScreen .card {
            width: min(360px, 90vw);
        }

        #cashoutScreen .summary {
            font-size: 18px;
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 18px;
        }

        @media (max-width: 768px) {
            body:not(.is-touch) #scorePanel,
            body:not(.is-touch) #leaderboard {
                top: auto;
                bottom: calc(24px + var(--safe-bottom));
            }

            body:not(.is-touch) #leaderboard {
                right: calc(24px + var(--safe-right));
            }

            body:not(.is-touch) #scorePanel {
                left: calc(24px + var(--safe-left));
            }

            body:not(.is-touch) #minimapPanel {
                top: calc(24px + var(--safe-top));
                bottom: auto;
                right: calc(24px + var(--safe-right));
                left: auto;
                width: clamp(180px, 32vw, 220px);
            }
        }

        @media (max-width: 540px) {
            .panel {
                padding: 14px 16px;
                border-radius: 16px;
            }

            #leaderboard .title,
            #scorePanel .label,
            #minimapPanel .title {
                font-size: 12px;
            }

            #leaderboard {
                width: clamp(180px, 40vw, 220px);
            }

            #minimapCanvas {
                border-radius: 14px;
            }

            body.is-touch #leaderboard,
            body.is-touch #scorePanel {
                width: clamp(170px, 48vw, 220px);
            }
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="scorePanel" class="panel">
    <div class="label">Длина</div>
    <div id="scoreValue">0</div>
    <div id="scoreMeta">Ранг: —</div>
    <div class="account">
        <div class="account-row">
            <span class="account-label">Баланс</span>
            <span class="account-value" id="balanceValue">0</span>
        </div>
        <div class="account-row">
            <span class="account-label">Ставка</span>
            <span class="account-value" id="betValue">0</span>
        </div>
    </div>
</div>
<div id="leaderboard" class="panel">
    <div class="title">Лидеры</div>
    <ol id="leaderboardList"></ol>
</div>
<div id="minimapPanel" class="panel">
    <div class="title">Карта</div>
    <canvas id="minimapCanvas" width="188" height="188"></canvas>
</div>
<div id="touchControls" class="touch-controls" aria-hidden="true">
    <div id="joystick" class="joystick" role="application" aria-label="Виртуальный джойстик">
        <div id="joystickHandle" class="joystick-handle"></div>
    </div>
    <button id="boostButton" class="boost-button" type="button" aria-pressed="false" aria-disabled="true" disabled>Ускорение</button>
</div>
<div id="cashoutControl">
    <button id="cashoutButton" class="cashout-button" type="button" disabled aria-disabled="true">Вывод</button>
    <div id="cashoutHint" class="cashout-hint">Удерживайте кнопку 2 секунды или нажмите Q</div>
</div>
<div id="nicknameScreen" class="overlay">
    <div class="card">
        <h2>Slither — онлайн арена</h2>
        <p>Выберите никнейм и скин, чтобы начать игру. На компьютере управляйте мышью и удерживайте её кнопку, чтобы ускориться. На смартфоне используйте виртуальный джойстик и кнопку ускорения.</p>
        <input id="nicknameInput" type="text" maxlength="16" placeholder="Ваш ник" autocomplete="off" />
        <div class="skin-picker">
            <div class="caption">
                <span>Скины</span>
                <span id="skinName">Sky</span>
            </div>
            <div id="skinList" class="skin-list"></div>
        </div>
        <div class="bet-control">
            <label for="betInput">Ставка перед стартом</label>
            <input id="betInput" type="number" min="1" step="1" value="10" />
            <div class="bet-hint">Доступно: <span id="betBalanceDisplay">1 000</span></div>
        </div>
        <button id="startBtn" class="primary">Играть</button>
    </div>
</div>
<div id="deathScreen" class="overlay hidden">
    <div class="card">
        <div class="summary" id="deathSummary"></div>
        <div class="score" id="deathScore"></div>
        <div class="death-balance" id="deathBalance"></div>
        <div class="bet-control" id="deathBetControl">
            <label for="retryBetInput">Новая ставка</label>
            <input id="retryBetInput" type="number" min="1" step="1" />
            <div class="bet-hint">Доступно: <span id="deathBetBalance">0</span></div>
        </div>
        <button class="primary" id="retryBtn">Играть снова</button>
    </div>
</div>
<div id="cashoutScreen" class="overlay hidden">
    <div class="card">
        <div class="summary" id="cashoutTitle">Баланс выведен</div>
        <div class="summary" id="cashoutSummary"></div>
        <button class="primary" id="cashoutCloseBtn">Готово</button>
    </div>
</div>
<script>
(() => {
    const DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1))
    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    const scoreValueEl = document.getElementById('scoreValue')
    const scoreMetaEl = document.getElementById('scoreMeta')
    const leaderboardList = document.getElementById('leaderboardList')
    const deathScreen = document.getElementById('deathScreen')
    const deathSummary = document.getElementById('deathSummary')
    const deathScore = document.getElementById('deathScore')
    const deathBalanceEl = document.getElementById('deathBalance')
    const deathBetControl = document.getElementById('deathBetControl')
    const deathBetBalanceEl = document.getElementById('deathBetBalance')
    const retryBetInput = document.getElementById('retryBetInput')
    const retryBtn = document.getElementById('retryBtn')
    const nicknameScreen = document.getElementById('nicknameScreen')
    const nicknameInput = document.getElementById('nicknameInput')
    const betInput = document.getElementById('betInput')
    const betBalanceDisplay = document.getElementById('betBalanceDisplay')
    const balanceValueEl = document.getElementById('balanceValue')
    const betValueEl = document.getElementById('betValue')
    const cashoutButton = document.getElementById('cashoutButton')
    const cashoutHint = document.getElementById('cashoutHint')
    const cashoutScreen = document.getElementById('cashoutScreen')
    const cashoutSummary = document.getElementById('cashoutSummary')
    const cashoutCloseBtn = document.getElementById('cashoutCloseBtn')
    const skinList = document.getElementById('skinList')
    const skinName = document.getElementById('skinName')
    const startBtn = document.getElementById('startBtn')
    const minimapCanvas = document.getElementById('minimapCanvas')
    const minimapCtx = minimapCanvas.getContext('2d')
    const touchControls = document.getElementById('touchControls')
    const joystick = document.getElementById('joystick')
    const joystickHandle = document.getElementById('joystickHandle')
    const boostButton = document.getElementById('boostButton')

    const SKINS = {
        default: ['#38bdf8'],
        emerald: ['#34d399'],
        crimson: ['#ef4444'],
        amber: ['#f59e0b'],
        violet: ['#a855f7'],
        obsidian: ['#475569'],
        mint: ['#14b8a6']
    }

    const SKIN_LABELS = {
        default: 'Sky',
        emerald: 'Emerald',
        crimson: 'Crimson',
        amber: 'Amber',
        violet: 'Violet',
        obsidian: 'Obsidian',
        mint: 'Mint'
    }

    const FOOD_PULSE_SPEED = 4.2
    const CAMERA_SMOOTH = 6.5
    const POSITION_SMOOTH = 14
    const ANGLE_SMOOTH = 12
    const CAMERA_ZOOM = 1.18
    const MAX_PREDICTION_SECONDS = 0.45
    const SERVER_TICK_RATE = 40
    const INTERPOLATION_DELAY = 0.12
    const NET_OFFSET_SMOOTH = 0.1
    const MAX_SNAPSHOT_BUFFER = 45
    const SEGMENT_SPACING = 6
    const LENGTH_EPS = 1e-3
    const MINIMAP_SIZE = 188
    const CASHOUT_HOLD_MS = 2000

    let cashoutHoldStart = null
    let cashoutHoldFrame = null
    let cashoutHoldTriggered = false
    let cashoutHoldSource = null
    let cashoutPending = false

    function setCanvasSize() {
        const width = window.innerWidth
        const height = window.innerHeight
        canvas.width = Math.round(width * DPR)
        canvas.height = Math.round(height * DPR)
        canvas.style.width = width + 'px'
        canvas.style.height = height + 'px'
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0)
    }

    function setMinimapSize() {
        if (!minimapCanvas) return
        const size = MINIMAP_SIZE
        minimapCanvas.width = Math.round(size * DPR)
        minimapCanvas.height = Math.round(size * DPR)
        minimapCanvas.style.width = size + 'px'
        minimapCanvas.style.height = size + 'px'
        minimapCtx.setTransform(DPR, 0, 0, DPR, 0, 0)
    }

    setCanvasSize()
    setMinimapSize()
    window.addEventListener('resize', () => {
        setCanvasSize()
        setMinimapSize()
        hexPattern = buildHexPattern()
    })

    let selectedSkin = 'default'

    function colorForSkin(colors) {
        if (!colors || colors.length === 0) return '#94a3b8'
        return colors[0]
    }

    function buildSkinPicker() {
        skinList.innerHTML = ''
        Object.entries(SKINS).forEach(([key, colors]) => {
            const btn = document.createElement('button')
            btn.type = 'button'
            btn.className = 'skin-option'
            btn.dataset.skin = key
            btn.dataset.name = SKIN_LABELS[key] || key
            btn.style.background = colorForSkin(colors)
            btn.style.backgroundImage = 'none'
            btn.addEventListener('click', () => {
                selectedSkin = key
                updateSkinPicker()
            })
            skinList.appendChild(btn)
        })
        updateSkinPicker()
    }

    function updateSkinPicker() {
        skinName.textContent = SKIN_LABELS[selectedSkin] || selectedSkin
        Array.from(skinList.children).forEach((child) => {
            child.classList.toggle('selected', child.dataset.skin === selectedSkin)
        })
    }

    function formatNumber(value) {
        const safe = Math.max(0, Math.floor(Number.isFinite(value) ? value : 0))
        return safe.toLocaleString('ru-RU')
    }

    function getTotalBalance() {
        const balance = Math.max(0, state.account.balance || 0)
        const bet = Math.max(0, state.account.currentBet || 0)
        return Math.max(0, state.account.total || balance + bet)
    }

    function applyBalanceUpdate(payload) {
        if (!payload) return
        if (typeof payload.balance === 'number') state.account.balance = Math.max(0, Math.floor(payload.balance))
        if (typeof payload.currentBet === 'number') state.account.currentBet = Math.max(0, Math.floor(payload.currentBet))
        if (typeof payload.total === 'number') {
            state.account.total = Math.max(0, Math.floor(payload.total))
        } else {
            state.account.total = Math.max(0, state.account.balance + state.account.currentBet)
        }
        if (typeof payload.cashedOut === 'boolean') {
            state.account.cashedOut = payload.cashedOut
            if (payload.cashedOut) {
                cashoutPending = false
            }
        }
        updateBalanceHUD()
    }

    function updateBalanceHUD() {
        if (balanceValueEl) balanceValueEl.textContent = formatNumber(state.account.balance)
        if (betValueEl) betValueEl.textContent = formatNumber(state.account.currentBet)
        if (betBalanceDisplay) betBalanceDisplay.textContent = formatNumber(state.account.balance)

        const total = getTotalBalance()
        const canCashOut = !state.account.cashedOut && !cashoutPending && total > 0 && ws && ws.readyState === WebSocket.OPEN

        if (cashoutButton) {
            const isHolding = cashoutHoldStart !== null && !cashoutHoldTriggered && !cashoutPending
            cashoutButton.disabled = !canCashOut
            cashoutButton.setAttribute('aria-disabled', canCashOut ? 'false' : 'true')
            if (!state.account.cashedOut) {
                if (cashoutPending) {
                    cashoutButton.textContent = 'Запрос вывода...'
                    cashoutButton.classList.remove('holding')
                } else if (!isHolding) {
                    cashoutButton.textContent = 'Вывод'
                    cashoutButton.classList.remove('holding')
                }
            }
        }
        if (cashoutHint) {
            cashoutHint.textContent = state.account.cashedOut
                ? 'Баланс зафиксирован'
                : cashoutPending
                    ? 'Запрос обрабатывается'
                    : 'Удерживайте кнопку 2 секунды или нажмите Q'
            cashoutHint.style.opacity = canCashOut ? '0.85' : '0.5'
        }
    }

    function sanitizeBetValue(value, maxBalance) {
        const max = Math.max(0, Math.floor(maxBalance || 0))
        if (max <= 0) return 0
        const raw = Math.floor(Number(value) || 0)
        if (raw < 1) return 1
        return Math.min(raw, max)
    }

    function canRequestCashout() {
        return !state.account.cashedOut && !cashoutPending && getTotalBalance() > 0 && ws && ws.readyState === WebSocket.OPEN
    }

    function resetCashoutHold(options = {}) {
        if (cashoutHoldFrame) cancelAnimationFrame(cashoutHoldFrame)
        cashoutHoldFrame = null
        cashoutHoldStart = null
        cashoutHoldSource = null
        cashoutHoldTriggered = false
        if (cashoutButton) {
            cashoutButton.classList.remove('holding')
            if (!state.account.cashedOut && !options.preserveLabel) {
                cashoutButton.textContent = 'Вывод'
            }
        }
    }

    function updateCashoutCountdown(now) {
        if (cashoutHoldStart === null) return
        const elapsed = now - cashoutHoldStart
        const remaining = Math.max(0, CASHOUT_HOLD_MS - elapsed)
        if (cashoutButton && !state.account.cashedOut) {
            if (remaining > 0) {
                cashoutButton.textContent = `Удерживайте ещё ${(remaining / 1000).toFixed(1)} с`
            } else {
                cashoutButton.textContent = 'Запрос вывода...'
            }
        }
        if (elapsed >= CASHOUT_HOLD_MS) {
            triggerCashout()
            return
        }
        cashoutHoldFrame = requestAnimationFrame(updateCashoutCountdown)
    }

    function startCashoutHold(source) {
        if (!canRequestCashout()) return
        if (cashoutHoldStart !== null) return
        cashoutHoldStart = performance.now()
        cashoutHoldSource = source
        cashoutHoldTriggered = false
        if (cashoutButton) cashoutButton.classList.add('holding')
        cashoutHoldFrame = requestAnimationFrame(updateCashoutCountdown)
    }

    function triggerCashout() {
        if (cashoutHoldTriggered) return
        cashoutHoldTriggered = true
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'cashout_request' }))
        }
        if (cashoutButton) {
            cashoutButton.textContent = 'Запрос вывода...'
        }
        cashoutPending = true
        resetCashoutHold({ preserveLabel: true })
        updateBalanceHUD()
    }

    function getMeSnake() {
        return state.meId ? state.snakes.get(state.meId) : null
    }

    function canBoost() {
        const me = getMeSnake()
        if (!me || !me.alive || !state.alive) return false
        const min = state.limits.boostMinLength || state.limits.minLength || 0
        return typeof me.length === 'number' && me.length > min + 1e-3
    }

    function refreshBoostState(force = false) {
        const allowed = canBoost()
        const active = allowed && state.boostIntent
        state.boostActive = active
        if ((force || allowed !== lastBoostAllowed || active !== lastBoostActive) && boostButton) {
            boostButton.disabled = !allowed
            boostButton.classList.toggle('disabled', !allowed)
            boostButton.classList.toggle('active', active)
            boostButton.setAttribute('aria-disabled', String(!allowed))
            boostButton.setAttribute('aria-pressed', active ? 'true' : 'false')
        }
        lastBoostAllowed = allowed
        lastBoostActive = active
        return { allowed, active }
    }

    function setBoostIntent(active) {
        const desired = Boolean(active)
        if (state.boostIntent !== desired) {
            state.boostIntent = desired
            refreshBoostState()
        } else if (!desired) {
            refreshBoostState()
        }
    }

    function resetBoostIntent() {
        if (!state.boostIntent && !state.boostActive) {
            refreshBoostState()
            return
        }
        state.boostIntent = false
        refreshBoostState()
    }

    function resetJoystickHandle() {
        if (joystickHandle) {
            joystickHandle.style.transform = 'translate(-50%, -50%)'
        }
    }

    function updateJoystickPosition(clientX, clientY) {
        if (!joystick || !joystickHandle) return
        const rect = joystick.getBoundingClientRect()
        const cx = rect.left + rect.width / 2
        const cy = rect.top + rect.height / 2
        const dx = clientX - cx
        const dy = clientY - cy
        const radius = rect.width / 2
        const distance = Math.min(radius, Math.hypot(dx, dy))
        const angle = Math.atan2(dy, dx)
        const offsetX = Math.cos(angle) * distance
        const offsetY = Math.sin(angle) * distance
        joystickHandle.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px)`
        state.pointerAngle = angle
    }


    let ws = null
    const state = {
        snakes: new Map(),
        foods: new Map(),
        leaderboard: [],
        meId: null,
        meName: '',
        alive: false,
        world: null,
        camera: { x: 0, y: 0, targetX: 0, targetY: 0, zoom: CAMERA_ZOOM, initialized: false },
        pointerAngle: null,
        boostIntent: false,
        boostActive: false,
        limits: { minLength: 0, baseLength: 0, boostMinLength: 0 },
        lastInputSent: 0,
        lastSnapshotAt: 0,
        account: { balance: 1000, currentBet: 0, total: 1000, cashedOut: false },
        pendingBet: null,
        net: {
            snapshots: [],
            timeOffset: null,
            lastSignature: null,
            lastServerTime: null
        }
    }

    const pointerMedia = window.matchMedia('(pointer: coarse)')
    let touchControlsEnabled = false
    let lastBoostAllowed = null
    let lastBoostActive = null
    let joystickActive = false

    function setTouchControlsEnabled(enabled) {
        touchControlsEnabled = Boolean(enabled)
        document.body.classList.toggle('is-touch', touchControlsEnabled)
        if (touchControls) {
            touchControls.classList.toggle('active', touchControlsEnabled)
            touchControls.setAttribute('aria-hidden', touchControlsEnabled ? 'false' : 'true')
        }
        resetJoystickHandle()
        resetBoostIntent()
        refreshBoostState(true)
    }

    const pointerChangeHandler = (event) => setTouchControlsEnabled(event.matches)
    setTouchControlsEnabled(pointerMedia.matches)
    if (typeof pointerMedia.addEventListener === 'function') {
        pointerMedia.addEventListener('change', pointerChangeHandler)
    } else if (typeof pointerMedia.addListener === 'function') {
        pointerMedia.addListener(pointerChangeHandler)
    }

    buildSkinPicker()
    renderLeaderboard()
    updateBalanceHUD()
    updateHUD(0)

    let hexPattern = buildHexPattern()

    function buildHexPattern() {
        const r = 35
        const W = Math.round(3 * r)
        const H = Math.round(Math.sqrt(3) * r)
        const off = document.createElement('canvas')
        off.width = W
        off.height = H
        const c = off.getContext('2d')

        const base = c.createLinearGradient(0, 0, W, H)
        base.addColorStop(0, '#0b0f16')
        base.addColorStop(1, '#151a24')
        c.fillStyle = base
        c.fillRect(0, 0, W, H)

        function hexPath(cx, cy) {
            const p = new Path2D()
            for (let i = 0; i < 6; i++) {
                const a = i * Math.PI / 3
                const x = cx + r * Math.cos(a)
                const y = cy + r * Math.sin(a)
                if (i === 0) p.moveTo(x, y)
                else p.lineTo(x, y)
            }
            p.closePath()
            return p
        }

        function drawHex(cx, cy) {
            const path = hexPath(cx, cy)

            c.save()
            c.fillStyle = '#111722'
            c.fill(path)

            c.save()
            c.clip(path)
            const inner = c.createRadialGradient(cx, cy, r * 0.2, cx, cy, r)
            inner.addColorStop(0, '#131a26')
            inner.addColorStop(0.65, '#0e1420')
            inner.addColorStop(1, '#0a0f18')
            c.fillStyle = inner
            c.fillRect(cx - r, cy - r, 2 * r, 2 * r)

            const topLight = c.createLinearGradient(cx - r, cy - r, cx + r, cy + r)
            topLight.addColorStop(0, 'rgba(97,123,163,0.22)')
            topLight.addColorStop(0.4, 'rgba(61,82,113,0.15)')
            topLight.addColorStop(1, 'rgba(0,0,0,0)')
            c.globalCompositeOperation = 'lighter'
            c.fillStyle = topLight
            c.fillRect(cx - r, cy - r, 2 * r, 2 * r)
            c.globalCompositeOperation = 'source-over'
            c.restore()

            c.lineJoin = 'round'
            c.lineWidth = Math.max(2, r * 0.1)
            const rim = c.createLinearGradient(cx - r, cy - r, cx + r, cy + r)
            rim.addColorStop(0, '#27384f')
            rim.addColorStop(0.5, '#1d2735')
            rim.addColorStop(1, '#121925')
            c.strokeStyle = rim
            c.stroke(path)

            c.save()
            c.clip(path)
            c.lineWidth = Math.max(1.2, r * 0.06)
            const innerRim = c.createLinearGradient(cx + r, cy - r, cx - r, cy + r)
            innerRim.addColorStop(0, 'rgba(59,130,246,0.24)')
            innerRim.addColorStop(1, 'rgba(12,23,38,0.42)')
            c.strokeStyle = innerRim
            c.stroke(path)
            c.restore()

            c.lineWidth = 10
            c.strokeStyle = '#0a0e14'
            c.stroke(path)


            c.restore()
        }

        const colStep = 1.5 * r
        const rowStep = Math.sqrt(3) * r

        for (let col = -1; col <= 2; col++) {
            const x = col * colStep + r + 0.5
            const yOff = (col & 1) ? rowStep / 2 : 0
            for (let row = -1; row <= 1; row++) {
                const y = row * rowStep + H / 2 + yOff + 0.5
                drawHex(x, y)
            }
        }

        return ctx.createPattern(off, 'repeat')
    }

    function connect(name, skin) {
        const origin = (typeof location !== 'undefined' && location.origin && location.origin !== 'null')
            ? location.origin.replace(/^http/, 'ws')
            : 'ws://83.222.22.106:8080'
        ws = new WebSocket(origin)
        ws.onopen = () => {
            ws.send(JSON.stringify({ type: 'join', name, skin }))
        }
        ws.onclose = () => {
            state.alive = false
            cashoutPending = false
            updateBalanceHUD()
        }
        ws.onmessage = (event) => {
            const message = safeParse(event.data)
            if (!message) return
            if (message.type === 'welcome') {
                state.meId = message.id
                state.alive = true
                cashoutPending = false
                applyBalanceUpdate({
                    balance: typeof message.balance === 'number' ? message.balance : state.account.balance,
                    currentBet: typeof message.currentBet === 'number' ? message.currentBet : state.account.currentBet,
                    total: (typeof message.balance === 'number' ? message.balance : state.account.balance) +
                        (typeof message.currentBet === 'number' ? message.currentBet : state.account.currentBet),
                    cashedOut: false
                })
                if (typeof message.width === 'number' && typeof message.height === 'number') {
                    const radius = typeof message.radius === 'number'
                        ? message.radius
                        : Math.min(message.width, message.height) / 2
                    state.world = {
                        width: message.width,
                        height: message.height,
                        radius,
                        centerX: message.width / 2,
                        centerY: message.height / 2
                    }
                    if (!state.camera.initialized) {
                        state.camera.x = state.world.centerX
                        state.camera.y = state.world.centerY
                        state.camera.targetX = state.world.centerX
                        state.camera.targetY = state.world.centerY
                        state.camera.initialized = true
                    }
                }
                state.camera.zoom = CAMERA_ZOOM
                if (typeof message.minLength === 'number') {
                    state.limits.minLength = message.minLength
                    state.limits.boostMinLength = message.minLength
                }
                if (typeof message.baseLength === 'number') {
                    state.limits.baseLength = message.baseLength
                    if (!state.limits.boostMinLength) {
                        state.limits.boostMinLength = message.baseLength
                    }
                }
                refreshBoostState(true)
                if (state.pendingBet !== null && ws.readyState === WebSocket.OPEN) {
                    const desired = sanitizeBetValue(state.pendingBet, state.account.balance)
                    if (desired > 0) {
                        ws.send(JSON.stringify({ type: 'set_bet', amount: desired }))
                    }
                    state.pendingBet = null
                }
            }
            if (message.type === 'snapshot') {
                state.lastSnapshotAt = performance.now()
                state.alive = message.you ? message.you.alive : state.alive
                if (message.leaderboard) {
                    state.leaderboard = message.leaderboard
                    renderLeaderboard()
                }
                if (message.you && (typeof message.you.balance === 'number' || typeof message.you.currentBet === 'number')) {
                    applyBalanceUpdate({
                        balance: message.you.balance,
                        currentBet: message.you.currentBet,
                        total: message.you.totalBalance
                    })
                }
                queueSnapshot(message)
            }
            if (message.type === 'death') {
                showDeath(message)
            }
            if (message.type === 'balance') {
                applyBalanceUpdate(message)
            }
            if (message.type === 'cashout_confirmed') {
                state.alive = false
                showCashout(typeof message.balance === 'number' ? message.balance : undefined)
            }
            if (message.type === 'error') {
                if (message.code === 'cashout_failed') {
                    cashoutPending = false
                    updateBalanceHUD()
                    resetCashoutHold()
                    if (cashoutButton) {
                        cashoutButton.textContent = 'Ошибка вывода'
                    }
                }
            }
        }
    }

    function safeParse(data) {
        try {
            return JSON.parse(data)
        } catch (err) {
            return null
        }
    }

    function applySnapshot(snapshot) {
        const seen = new Set()
        if (Array.isArray(snapshot.players)) {
            snapshot.players.forEach((payload) => {
                if (!payload || !payload.id) return
                seen.add(payload.id)
                upsertSnake(payload)
            })
        }
        if (snapshot.you && snapshot.you.id) {
            seen.add(snapshot.you.id)
        }
        for (const [id] of state.snakes) {
            if (!seen.has(id)) {
                state.snakes.delete(id)
            }
        }

        const foodSeen = new Set()
        if (Array.isArray(snapshot.foods)) {
            snapshot.foods.forEach((f) => {
                if (!f || !f.id) return
                foodSeen.add(f.id)
                let food = state.foods.get(f.id)
                if (!food) {
                    food = {
                        id: f.id,
                        displayX: f.x,
                        displayY: f.y,
                        life: 0
                    }
                    state.foods.set(f.id, food)
                }
                food.targetX = f.x
                food.targetY = f.y
                food.value = typeof f.v === 'number' ? f.v : 1
                if (f.color && /^#/.test(f.color)) {
                    food.color = f.color
                } else if (!food.color) {
                    food.color = randomFoodColor(f.id)
                }
                food.big = Boolean(f.big)
                if (typeof f.pulse === 'number') food.pulse = f.pulse
                else if (typeof food.pulse !== 'number') food.pulse = Math.random() * Math.PI * 2
            })
        }
        for (const [id] of state.foods) {
            if (!foodSeen.has(id)) state.foods.delete(id)
        }
    }

    function queueSnapshot(snapshot) {
        if (!snapshot) return
        const nowSeconds = performance.now() / 1000
        let serverTime = typeof snapshot.tick === 'number' ? snapshot.tick / SERVER_TICK_RATE : null
        if (!Number.isFinite(serverTime)) {
            if (typeof state.net.lastServerTime === 'number' && Number.isFinite(state.net.lastServerTime)) {
                serverTime = state.net.lastServerTime + (1 / SERVER_TICK_RATE)
            } else {
                serverTime = nowSeconds
            }
        }
        state.net.lastServerTime = serverTime
        const offsetSample = nowSeconds - serverTime
        if (!Number.isFinite(state.net.timeOffset)) {
            state.net.timeOffset = offsetSample
        } else {
            state.net.timeOffset = lerp(state.net.timeOffset, offsetSample, NET_OFFSET_SMOOTH)
        }
        state.net.snapshots.push({
            message: snapshot,
            serverTime,
            arrival: nowSeconds
        })
        if (state.net.snapshots.length > MAX_SNAPSHOT_BUFFER) {
            state.net.snapshots.splice(0, state.net.snapshots.length - MAX_SNAPSHOT_BUFFER)
        }
        state.net.lastSignature = null
    }

    function syncSnapshotBuffer() {
        const net = state.net
        if (!net || net.snapshots.length === 0) return
        const nowSeconds = performance.now() / 1000
        let renderTime
        if (Number.isFinite(net.timeOffset)) {
            renderTime = nowSeconds - net.timeOffset - INTERPOLATION_DELAY
        } else {
            renderTime = net.snapshots[net.snapshots.length - 1].serverTime
        }
        let prev = net.snapshots[0]
        let next = net.snapshots[net.snapshots.length - 1]
        for (let i = 0; i < net.snapshots.length; i++) {
            const item = net.snapshots[i]
            if (item.serverTime <= renderTime) {
                prev = item
            }
            if (item.serverTime >= renderTime) {
                next = item
                break
            }
        }
        if (renderTime <= net.snapshots[0].serverTime) {
            prev = net.snapshots[0]
            next = net.snapshots[1] || prev
        } else if (renderTime >= net.snapshots[net.snapshots.length - 1].serverTime) {
            prev = net.snapshots[net.snapshots.length - 2] || net.snapshots[net.snapshots.length - 1]
            next = net.snapshots[net.snapshots.length - 1]
        }
        let alpha = 0
        if (next !== prev) {
            const span = next.serverTime - prev.serverTime
            if (span > 1e-4) {
                alpha = (renderTime - prev.serverTime) / span
            }
        } else if (renderTime > next.serverTime) {
            alpha = 1
        }
        if (!Number.isFinite(alpha)) alpha = 0
        alpha = Math.max(0, Math.min(1, alpha))
        const quantAlpha = Math.max(0, Math.min(1, Math.round(alpha * 2) / 2))
        const signature = `${prev.message.tick || 'p'}:${next.message.tick || 'n'}:${quantAlpha.toFixed(1)}`
        if (signature === net.lastSignature) return
        const snapshot = next === prev
            ? cloneSnapshot(next.message)
            : blendSnapshots(prev.message, next.message, quantAlpha)
        applySnapshot(snapshot)
        net.lastSignature = signature
        refreshBoostState()
        if (snapshot.you && typeof snapshot.you.length === 'number') {
            updateHUD(Math.floor(snapshot.you.length))
        } else {
            const meSnake = getMeSnake()
            if (meSnake && typeof meSnake.length === 'number') {
                updateHUD(Math.floor(meSnake.length))
            }
        }
        const pivotIndex = net.snapshots.indexOf(prev)
        if (pivotIndex > 1) {
            net.snapshots.splice(0, pivotIndex - 1)
        }
    }

    function cloneSnapshot(snapshot) {
        if (!snapshot) return null
        return {
            type: snapshot.type,
            tick: snapshot.tick,
            you: snapshot.you ? { ...snapshot.you } : null,
            players: Array.isArray(snapshot.players)
                ? snapshot.players.map((p) => (p ? { ...p } : p))
                : [],
            foods: Array.isArray(snapshot.foods)
                ? snapshot.foods.map((f) => (f ? { ...f } : f))
                : [],
            leaderboard: Array.isArray(snapshot.leaderboard)
                ? snapshot.leaderboard.map((entry) => ({ ...entry }))
                : snapshot.leaderboard
        }
    }

    function blendSnapshots(prev, next, alpha) {
        if (!prev && !next) return null
        if (!prev) return cloneSnapshot(next)
        if (!next) return cloneSnapshot(prev)
        const prevPlayers = snapshotPlayersToMap(prev)
        const nextPlayers = snapshotPlayersToMap(next)
        const ids = new Set([...prevPlayers.keys(), ...nextPlayers.keys()])
        const prevYou = prev.you && prev.you.id ? prev.you : null
        const nextYou = next.you && next.you.id ? next.you : null
        const youId = nextYou?.id || prevYou?.id || null
        const players = []
        let youPayload = null
        ids.forEach((id) => {
            const a = prevPlayers.get(id)
            const b = nextPlayers.get(id)
            const base = b || a
            if (!base) return
            const sample = { ...base }
            if (a && b) {
                if (typeof a.x === 'number' && typeof b.x === 'number') sample.x = lerp(a.x, b.x, alpha)
                if (typeof a.y === 'number' && typeof b.y === 'number') sample.y = lerp(a.y, b.y, alpha)
                if (typeof a.length === 'number' && typeof b.length === 'number') sample.length = lerp(a.length, b.length, alpha)
                if (typeof a.speed === 'number' && typeof b.speed === 'number') sample.speed = lerp(a.speed, b.speed, alpha)
                if (typeof a.angle === 'number' && typeof b.angle === 'number') sample.angle = lerpAngle(a.angle, b.angle, alpha)
                if (typeof a.dir === 'number' && typeof b.dir === 'number') sample.dir = lerpAngle(a.dir, b.dir, alpha)
            }
            if (!sample.path) {
                sample.path = (alpha > 0.5 ? b?.path : a?.path) || sample.path
            }
            if (id === youId) {
                youPayload = sample
            } else {
                players.push(sample)
            }
        })
        const prevFoods = snapshotFoodsToMap(prev)
        const nextFoods = snapshotFoodsToMap(next)
        const foodIds = new Set([...prevFoods.keys(), ...nextFoods.keys()])
        const foods = []
        foodIds.forEach((id) => {
            const a = prevFoods.get(id)
            const b = nextFoods.get(id)
            const base = b || a
            if (!base) return
            const sample = { ...base }
            if (a && b) {
                if (typeof a.x === 'number' && typeof b.x === 'number') sample.x = lerp(a.x, b.x, alpha)
                if (typeof a.y === 'number' && typeof b.y === 'number') sample.y = lerp(a.y, b.y, alpha)
            }
            foods.push(sample)
        })
        return {
            type: next.type || prev.type || 'snapshot',
            tick: typeof next.tick === 'number' && !Number.isNaN(next.tick)
                ? next.tick
                : prev.tick,
            you: youPayload,
            players,
            foods,
            leaderboard: next.leaderboard || prev.leaderboard
        }
    }

    function snapshotPlayersToMap(snapshot) {
        const map = new Map()
        if (!snapshot) return map
        if (Array.isArray(snapshot.players)) {
            snapshot.players.forEach((p) => {
                if (p && p.id) map.set(p.id, p)
            })
        }
        if (snapshot.you && snapshot.you.id) {
            map.set(snapshot.you.id, snapshot.you)
        }
        return map
    }

    function snapshotFoodsToMap(snapshot) {
        const map = new Map()
        if (!snapshot || !Array.isArray(snapshot.foods)) return map
        snapshot.foods.forEach((f) => {
            if (f && f.id) map.set(f.id, f)
        })
        return map
    }

    function randomFoodColor(seed) {
        const palette = ['#ffd166', '#fca311', '#ff5e57', '#4cd137', '#00e5ff', '#7d5fff', '#ff8bd2', '#b7fbff', '#caffbf', '#fdffb6', '#ffd6a5', '#bdb2ff']
        const text = typeof seed === 'string' ? seed : String(seed)
        let acc = 0
        for (let i = 0; i < text.length; i++) acc = (acc + text.charCodeAt(i)) % palette.length
        return palette[acc]
    }

    function upsertSnake(payload) {
        const id = payload.id
        const now = performance.now()
        const rawDir = typeof payload.dir === 'number'
            ? payload.dir
            : (typeof payload.angle === 'number' ? payload.angle : 0)
        const rawAngle = typeof payload.angle === 'number' ? payload.angle : rawDir
        let snake = state.snakes.get(id)
        const previousSpeed = snake && typeof snake.speed === 'number' ? snake.speed : 0
        const speed = typeof payload.speed === 'number' ? payload.speed : previousSpeed
        if (!snake) {
            snake = {
                id,
                displayX: payload.x,
                displayY: payload.y,
                targetX: payload.x,
                targetY: payload.y,
                displayAngle: rawAngle,
                targetAngle: rawAngle,
                displayDir: rawDir,
                targetDir: rawDir,
                renderPath: [],
                length: payload.length || 0,
                displayLength: payload.length || 0,
                speed: speed,
                alive: payload.alive,
                name: payload.name || '',
                skin: payload.skin || 'default',
                serverX: payload.x,
                serverY: payload.y,
                serverAngle: rawAngle,
                serverDir: rawDir,
                velocityX: Math.cos(rawDir) * speed,
                velocityY: Math.sin(rawDir) * speed,
                lastServerAt: now
            }
            state.snakes.set(id, snake)
        }
        snake.serverX = payload.x
        snake.serverY = payload.y
        snake.serverAngle = rawAngle
        snake.serverDir = rawDir
        snake.lastServerAt = now
        snake.velocityX = Math.cos(rawDir) * speed
        snake.velocityY = Math.sin(rawDir) * speed
        snake.targetX = payload.x
        snake.targetY = payload.y
        snake.targetAngle = rawAngle
        snake.targetDir = rawDir
        snake.length = payload.length || snake.length
        snake.speed = speed
        snake.samplePhase = 0;
        snake.alive = payload.alive
        snake.name = payload.name || ''
        snake.skin = payload.skin || 'default'
        if (typeof snake.displayLength !== 'number') snake.displayLength = snake.length
        const rawPath = Array.isArray(payload.path) ? payload.path : []
        const rebuiltPath = rebuildPath(rawPath, payload.x, payload.y, snake.length, rawDir)
        smoothAssignPath(snake, rebuiltPath)
    }

    function rebuildPath(points, headX, headY, length, angle) {
        const result = []
        const sourcePoints = Array.isArray(points) ? points : []
        const targetLength = Math.max(typeof length === 'number' ? length : 0, SEGMENT_SPACING * 2)
        const maxPoints = Math.max(2, 1 + Math.ceil(targetLength / SEGMENT_SPACING))
        const sampleWindow = Math.min(sourcePoints.length, Math.max(400, maxPoints + 12))
        const tail = sourcePoints.slice(-sampleWindow)
        for (let i = 0; i < tail.length; i++) {
            const pt = tail[i]
            if (typeof pt.x === 'number' && typeof pt.y === 'number') {
                result.push({ x: pt.x, y: pt.y })
            }
        }
        if (!result.length || result[result.length - 1].x !== headX || result[result.length - 1].y !== headY) {
            result.push({ x: headX, y: headY })
        }
        if (result.length < 2) {
            const dir = typeof angle === 'number' ? angle : 0
            const backOffset = Math.max(24, Math.min(120, 12 + Math.sqrt(Math.max(length, 1)) * 14))
            result.unshift({
                x: headX - Math.cos(dir) * backOffset,
                y: headY - Math.sin(dir) * backOffset
            })
        }
        let resampled = resamplePath(result, SEGMENT_SPACING)
        if (resampled.length > maxPoints) {
            resampled = resampled.slice(resampled.length - maxPoints)
        }
        fitPathLength(resampled, targetLength, SEGMENT_SPACING)
        return resampled
    }

    function smoothAssignPath(snake, targetPath) {
        if (!targetPath || !targetPath.length) {
            snake.renderPath = []
            return
        }
        if (!snake.renderPath || !snake.renderPath.length) {
            snake.renderPath = targetPath.map((p) => ({ x: p.x, y: p.y }))
            fitPathLength(snake.renderPath, Math.max(SEGMENT_SPACING * 2, snake.length || 0), SEGMENT_SPACING)
            return
        }
        const smoothed = []
        const prev = snake.renderPath
        const blend = 0.65
        const tailLock = Math.min(6, targetPath.length)
        for (let i = 0; i < targetPath.length; i++) {
            const target = targetPath[i]
            if (i < tailLock) {
                smoothed.push({ x: target.x, y: target.y })
            } else if (i === targetPath.length - 1 || i >= prev.length) {
                smoothed.push({ x: target.x, y: target.y })
            } else {
                const point = prev[i]
                smoothed.push({
                    x: lerp(point.x, target.x, blend),
                    y: lerp(point.y, target.y, blend)
                })
            }
        }
        snake.renderPath = smoothed
        fitPathLength(snake.renderPath, Math.max(SEGMENT_SPACING * 2, snake.length || 0), SEGMENT_SPACING)
    }

    function resamplePath(points, spacing) {
        if (!points || points.length < 2) return points || []
        const output = [{ x: points[0].x, y: points[0].y }]
        let prev = points[0]
        let carry = 0
        for (let i = 1; i < points.length; i++) {
            const current = points[i]
            let dx = current.x - prev.x
            let dy = current.y - prev.y
            let segLength = Math.hypot(dx, dy)
            if (segLength === 0) continue
            while (carry + segLength >= spacing) {
                const remain = spacing - carry
                const t = remain / segLength
                const nx = prev.x + dx * t
                const ny = prev.y + dy * t
                output.push({ x: nx, y: ny })
                prev = { x: nx, y: ny }
                dx = current.x - prev.x
                dy = current.y - prev.y
                segLength = Math.hypot(dx, dy)
                carry = 0
            }
            carry += segLength
            prev = current
        }
        const last = points[points.length - 1]
        if (output.length === 0 || output[output.length - 1].x !== last.x || output[output.length - 1].y !== last.y) {
            output.push({ x: last.x, y: last.y })
        }
        return output
    }

    function normalizePathStart(points) {
        if (!points) return
        while (points.length > 1) {
            const first = points[0]
            const second = points[1]
            if (!first || !second) break
            if (!Number.isFinite(first.x) || !Number.isFinite(first.y)) {
                points.shift()
                continue
            }
            if (!Number.isFinite(second.x) || !Number.isFinite(second.y)) {
                points.splice(1, 1)
                continue
            }
            const segLen = Math.hypot(second.x - first.x, second.y - first.y)
            if (segLen <= LENGTH_EPS) {
                points.shift()
            } else {
                break
            }
        }
    }

    function pathLength(points) {
        if (!Array.isArray(points) || points.length < 2) return 0
        let total = 0
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1]
            const cur = points[i]
            if (!prev || !cur) continue
            const dx = cur.x - prev.x
            const dy = cur.y - prev.y
            total += Math.hypot(dx, dy)
        }
        return total
    }

    function trimPathFront(points, amount) {
        if (!Array.isArray(points) || points.length < 2) return
        let remaining = amount
        while (remaining > LENGTH_EPS && points.length > 1) {
            normalizePathStart(points)
            if (points.length <= 1) break
            const first = points[0]
            const second = points[1]
            const dx = second.x - first.x
            const dy = second.y - first.y
            const segLen = Math.hypot(dx, dy)
            if (segLen <= LENGTH_EPS) {
                points.shift()
                continue
            }
            if (segLen <= remaining) {
                points.shift()
                remaining -= segLen
            } else {
                const ratio = remaining / segLen
                points[0] = {
                    x: first.x + dx * ratio,
                    y: first.y + dy * ratio
                }
                remaining = 0
            }
        }
    }

    function fitPathLength(points, targetLength, spacing) {
        if (!Array.isArray(points) || points.length < 2) return
        const safeTarget = Math.max(targetLength || 0, SEGMENT_SPACING * 2)
        let total = pathLength(points)
        if (!Number.isFinite(total)) return
        if (total > safeTarget + SEGMENT_SPACING * 0.25) {
            trimPathFront(points, total - safeTarget)
        }
    }

    function updateHUD(score) {
        scoreValueEl.textContent = (score || 0).toLocaleString('ru-RU')
        const rank = getRank()
        const meSnake = getMeSnake()
        const speed = meSnake && meSnake.speed ? Math.max(0, Math.round(meSnake.speed)) : null
        const boostStatus = refreshBoostState()
        const boostLabel = boostStatus.allowed
            ? (boostStatus.active ? 'Буст: вкл.' : 'Буст: готов')
            : 'Буст: нет'
        scoreMetaEl.textContent = speed
            ? `Ранг: ${rank} · Скорость: ${speed} · ${boostLabel}`
            : `Ранг: ${rank} · ${boostLabel}`
    }

    function getRank() {
        if (!state.leaderboard || !state.leaderboard.length || !state.meName) return '—'
        const index = state.leaderboard.findIndex((entry) => entry && entry.name === state.meName)
        if (index === -1) return state.leaderboard.length >= 10 ? '10+' : '—'
        return index + 1
    }

    function renderLeaderboard() {
        leaderboardList.innerHTML = ''
        state.leaderboard.slice(0, 10).forEach((entry, idx) => {
            const li = document.createElement('li')
            if (entry && entry.name === state.meName) {
                li.classList.add('me')
            }
            const nameSpan = document.createElement('span')
            nameSpan.className = 'name'
            nameSpan.textContent = `${idx + 1}. ${entry?.name || 'Anon'}`
            const scoreSpan = document.createElement('span')
            const value = entry && typeof entry.length === 'number' ? entry.length : 0
            scoreSpan.textContent = value.toLocaleString('ru-RU')
            li.appendChild(nameSpan)
            li.appendChild(scoreSpan)
            leaderboardList.appendChild(li)
        })
    }

    function showDeath(message) {
        state.alive = false
        cashoutPending = false
        resetBoostIntent()
        resetCashoutHold()
        const killerName = message && message.killerName ? message.killerName : 'неизвестный'
        const score = message && typeof message.yourScore === 'number' ? message.yourScore : 0
        const balance = Math.max(0, state.account.balance || 0)
        deathSummary.textContent = `Вас победил ${killerName}`
        deathScore.textContent = `Счёт: ${score.toLocaleString('ru-RU')}`
        if (deathBalanceEl) {
            deathBalanceEl.textContent = balance > 0
                ? `На счету осталось ${formatNumber(balance)} очков`
                : 'Баланс обнулён'
        }
        if (deathBetBalanceEl) deathBetBalanceEl.textContent = formatNumber(balance)
        if (retryBetInput) {
            if (balance > 0) {
                const suggested = sanitizeBetValue(retryBetInput.value || balance, balance)
                retryBetInput.value = suggested
                retryBetInput.disabled = false
            } else {
                retryBetInput.value = ''
                retryBetInput.disabled = true
            }
        }
        if (retryBtn) {
            const canRetry = balance > 0
            retryBtn.disabled = !canRetry
            retryBtn.setAttribute('aria-disabled', canRetry ? 'false' : 'true')
        }
        if (deathBetControl) {
            deathBetControl.style.display = balance > 0 ? 'block' : 'none'
        }
        deathScreen.classList.remove('hidden')
        updateHUD(0)
        updateBalanceHUD()
    }

    function showCashout(finalBalance) {
        state.alive = false
        cashoutPending = false
        resetBoostIntent()
        resetCashoutHold()
        const safeBalance = Math.max(0, Math.floor(typeof finalBalance === 'number' ? finalBalance : getTotalBalance()))
        deathScreen.classList.add('hidden')
        applyBalanceUpdate({ balance: safeBalance, currentBet: 0, total: safeBalance, cashedOut: true })
        if (cashoutSummary) {
            cashoutSummary.textContent = `Ваш балланс теперь ${formatNumber(safeBalance)} .`
        }
        if (cashoutButton) {
            cashoutButton.textContent = 'Баланс выведен'
            cashoutButton.disabled = true
            cashoutButton.setAttribute('aria-disabled', 'true')
        }
        if (cashoutScreen) {
            cashoutScreen.classList.remove('hidden')
        }
        updateHUD(0)
    }

    retryBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            window.location.reload()
            return
        }
        const balance = Math.max(0, state.account.balance || 0)
        if (balance <= 0) {
            window.location.reload()
            return
        }
        const betAmount = sanitizeBetValue(retryBetInput ? retryBetInput.value : balance, balance)
        if (betAmount <= 0) return
        ws.send(JSON.stringify({ type: 'set_bet', amount: betAmount }))
        ws.send(JSON.stringify({ type: 'respawn' }))
        state.pendingBet = null
        retryBtn.disabled = true
        retryBtn.setAttribute('aria-disabled', 'true')
        deathScreen.classList.add('hidden')
    })

    function lerp(a, b, t) {
        return a + (b - a) * t
    }

    function lerpAngle(a, b, t) {
        let diff = b - a
        while (diff < -Math.PI) diff += Math.PI * 2
        while (diff > Math.PI) diff -= Math.PI * 2
        return a + diff * t
    }

    function withAlpha(hex, alpha) {
        const value = parseInt(hex.slice(1), 16)
        const r = (value >> 16) & 255
        const g = (value >> 8) & 255
        const b = value & 255
        return `rgba(${r},${g},${b},${alpha})`
    }

    function shadeColor(hex, amt) {
        const value = parseInt(hex.slice(1), 16)
        let r = (value >> 16) & 255
        let g = (value >> 8) & 255
        let b = value & 255
        if (amt >= 0) {
            r = Math.round(r + (255 - r) * amt)
            g = Math.round(g + (255 - g) * amt)
            b = Math.round(b + (255 - b) * amt)
        } else {
            const t = -amt
            r = Math.round(r * (1 - t))
            g = Math.round(g * (1 - t))
            b = Math.round(b * (1 - t))
        }
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
    }

    function update(dt) {
        syncSnapshotBuffer()
        const smoothPos = Math.min(1, dt * POSITION_SMOOTH)
        const smoothAngle = Math.min(1, dt * ANGLE_SMOOTH)
        const now = performance.now()
        for (const snake of state.snakes.values()) {
            if (typeof snake.serverX === 'number' && typeof snake.serverY === 'number') {
                const elapsed = Math.max(0, Math.min(MAX_PREDICTION_SECONDS, (now - (snake.lastServerAt || now)) / 1000))
                const vx = snake.velocityX || 0
                const vy = snake.velocityY || 0
                const predictedX = snake.serverX + vx * elapsed
                const predictedY = snake.serverY + vy * elapsed
                snake.targetX = predictedX
                snake.targetY = predictedY
                if (vx || vy) {
                    const heading = Math.atan2(vy, vx)
                    if (Number.isFinite(heading)) {
                        snake.targetDir = heading
                        snake.targetAngle = heading
                    }
                } else if (typeof snake.serverAngle === 'number') {
                    snake.targetAngle = snake.serverAngle
                }
                // плавно двигаем последний (головной) узел пути к предсказанной позиции,
// чтобы не было резких замен и коротких прямых отрезков
                if (snake.renderPath && snake.renderPath.length) {
                    const lastIdx = snake.renderPath.length - 1
                    const last = snake.renderPath[lastIdx]
                    if (last) {
                        const dx = predictedX - last.x
                        const dy = predictedY - last.y
                        const dist = Math.hypot(dx, dy)
                        const maxStep = Math.max(SEGMENT_SPACING * 1.05, 8) // ограничение максимального «скачка»
                        if (dist > maxStep) {
                            const t = maxStep / dist
                            last.x = last.x + dx * t
                            last.y = last.y + dy * t
                        } else {
                            // небольшая интерполяция до предсказанной позиции
                            last.x = lerp(last.x, predictedX, 0.72)
                            last.y = lerp(last.y, predictedY, 0.72)
                        }
                    }
                }

            }
            if (snake.renderPath && snake.renderPath.length > 1) {
                const desiredLength = Math.max(SEGMENT_SPACING * 2, snake.length || snake.displayLength || 0)
                fitPathLength(snake.renderPath, desiredLength, SEGMENT_SPACING)
            }
            const baseX = typeof snake.displayX === 'number' ? snake.displayX : snake.targetX
            const baseY = typeof snake.displayY === 'number' ? snake.displayY : snake.targetY
            const baseAngle = typeof snake.displayAngle === 'number' ? snake.displayAngle : snake.targetAngle
            const baseDir = typeof snake.displayDir === 'number' ? snake.displayDir : snake.targetDir
            snake.displayX = lerp(baseX, snake.targetX, smoothPos)
            snake.displayY = lerp(baseY, snake.targetY, smoothPos)
            snake.displayAngle = lerpAngle(baseAngle, snake.targetAngle, smoothAngle)
            snake.displayDir = lerpAngle(baseDir, snake.targetDir, smoothAngle)
            snake.displayLength = snake.length
            if (!snake.alive && snake.renderPath.length) {
                snake.renderPath = snake.renderPath.slice(-1)
            }
        }

        const camTarget = state.meId && state.snakes.get(state.meId)
        if (camTarget) {
            state.camera.targetX = camTarget.displayX
            state.camera.targetY = camTarget.displayY
        } else if (state.world && !state.camera.initialized) {
            state.camera.targetX = state.world.centerX
            state.camera.targetY = state.world.centerY
        }
        const camBaseX = typeof state.camera.x === 'number' ? state.camera.x : state.camera.targetX
        const camBaseY = typeof state.camera.y === 'number' ? state.camera.y : state.camera.targetY
        const camK = Math.min(1, dt * CAMERA_SMOOTH)
        state.camera.x = lerp(camBaseX, state.camera.targetX, camK)
        state.camera.y = lerp(camBaseY, state.camera.targetY, camK)

        for (const food of state.foods.values()) {
            const baseX = typeof food.displayX === 'number' ? food.displayX : food.targetX
            const baseY = typeof food.displayY === 'number' ? food.displayY : food.targetY
            food.displayX = lerp(baseX, food.targetX, smoothPos)
            food.displayY = lerp(baseY, food.targetY, smoothPos)
            food.life = Math.min(1, (food.life || 0) + dt * 3.2)
        }
    }

    function draw(time) {
        const width = canvas.width / DPR
        const height = canvas.height / DPR
        const zoom = state.camera.zoom || 1
        drawBackground(state.camera.x, state.camera.y, width, height, zoom)
        drawFoods(state.camera.x, state.camera.y, time, zoom)
        drawSnakes(state.camera.x, state.camera.y, zoom)
        drawMinimap()
    }

    function drawBackground(camX, camY, width, height, zoom) {
        ctx.save()
        ctx.fillStyle = '#05070d'
        ctx.fillRect(0, 0, width, height)
        ctx.translate(width / 2, height / 2)
        ctx.scale(zoom, zoom)
        ctx.translate(-camX, -camY)
        ctx.globalAlpha = 0.9
        const pad = Math.max(width, height) * 1.6 / Math.max(zoom, 0.001)
        if (state.world) {
            const { centerX, centerY, radius } = state.world
            ctx.save()
            ctx.beginPath()
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)
            ctx.clip()
            ctx.fillStyle = hexPattern
            ctx.fillRect(centerX - radius - pad, centerY - radius - pad, (radius + pad) * 2, (radius + pad) * 2)
            ctx.restore()
            ctx.lineWidth = Math.max(8 / zoom, 4)
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.28)'
            ctx.beginPath()
            ctx.arc(centerX, centerY, radius + Math.max(12 / zoom, 6), 0, Math.PI * 2)
            ctx.stroke()
            ctx.lineWidth = Math.max(2.5 / zoom, 1.4)
            ctx.strokeStyle = 'rgba(37, 99, 235, 0.18)'
            ctx.beginPath()
            ctx.arc(centerX, centerY, radius - Math.max(18 / zoom, 9), 0, Math.PI * 2)
            ctx.stroke()
        } else {
            ctx.fillStyle = hexPattern
            ctx.fillRect(camX - pad, camY - pad, pad * 2, pad * 2)
        }
        ctx.restore()

        const vignette = ctx.createRadialGradient(
            width / 2,
            height / 2,
            Math.min(width, height) * 0.2,
            width / 2,
            height / 2,
            Math.max(width, height) * 0.75
        )
        vignette.addColorStop(0, 'rgba(5, 9, 16, 0)')
        vignette.addColorStop(1, 'rgba(0, 0, 0, 0.65)')
        ctx.fillStyle = vignette
        ctx.fillRect(0, 0, width, height)
    }

    function drawFoods(camX, camY, time, zoom) {
        ctx.save()
        const halfWidth = canvas.width / DPR / 2
        const halfHeight = canvas.height / DPR / 2
        ctx.translate(halfWidth, halfHeight)
        ctx.scale(zoom, zoom)
        ctx.translate(-camX, -camY)
        if (state.world) {
            ctx.beginPath()
            ctx.arc(state.world.centerX, state.world.centerY, state.world.radius, 0, Math.PI * 2)
            ctx.clip()
        }
        ctx.globalCompositeOperation = 'lighter'
        for (const food of state.foods.values()) {
            const color = food.color || '#ffd166'
            const pulse = 1 + Math.sin(time * FOOD_PULSE_SPEED + (food.pulse || 0)) * 0.16
            const magnitude = Math.pow(Math.max(food.value || 1, 1), 0.6)
            const baseSize = food.big ? 6.6 : 4.8
            const radius = (baseSize + magnitude * (food.big ? 1.45 : 1.1)) * pulse
            const fx = typeof food.displayX === 'number' ? food.displayX : food.targetX
            const fy = typeof food.displayY === 'number' ? food.displayY : food.targetY
            ctx.globalAlpha = (food.big ? 0.95 : 0.88) * (food.life || 1)
            ctx.shadowBlur = food.big ? 38 : 24
            ctx.shadowColor = withAlpha(color, food.big ? 0.75 : 0.5)
            const gradient = ctx.createRadialGradient(fx, fy, radius * 0.22, fx, fy, radius)
            gradient.addColorStop(0, '#ffffff')
            gradient.addColorStop(0.25, shadeColor(color, 0.2))
            gradient.addColorStop(1, shadeColor(color, -0.45))
            ctx.fillStyle = gradient
            ctx.beginPath()
            ctx.arc(fx, fy, radius, 0, Math.PI * 2)
            ctx.fill()
        }
        ctx.restore()
        ctx.globalAlpha = 1
        ctx.shadowBlur = 0
        ctx.shadowColor = 'transparent'
        ctx.globalCompositeOperation = 'source-over'
    }

    function drawSnakes(camX, camY, zoom) {
        const snakes = Array.from(state.snakes.values()).filter((s) => s.alive)
        snakes.sort((a, b) => (a.displayLength || 0) - (b.displayLength || 0))
        ctx.save()
        const halfWidth = canvas.width / DPR / 2
        const halfHeight = canvas.height / DPR / 2
        ctx.translate(halfWidth, halfHeight)
        ctx.scale(zoom, zoom)
        ctx.translate(-camX, -camY)
        if (state.world) {
            ctx.beginPath()
            ctx.arc(state.world.centerX, state.world.centerY, state.world.radius, 0, Math.PI * 2)
            ctx.clip()
        }
        for (const snake of snakes) {
            const path = snake.renderPath
            if (!path || path.length < 2) continue
            const colors = SKINS[snake.skin] || SKINS.default
            const baseColor = colors[0] || '#94a3b8'
            const displayLength = snake.displayLength || snake.length || 20
            const bodyRadius = Math.max(7.2, Math.min(30, 6.4 + Math.pow(Math.max(displayLength, 1), 0.42)))
            const headRadius = bodyRadius * 1.02
            const headX = typeof snake.displayX === 'number' ? snake.displayX : snake.targetX
            const headY = typeof snake.displayY === 'number' ? snake.displayY : snake.targetY
            const head = { x: headX, y: headY }
            path[path.length - 1] = { x: head.x, y: head.y }

            ctx.lineJoin = 'round'
            ctx.lineCap = 'round'
            ctx.strokeStyle = shadeColor(baseColor, -0.55)
            ctx.lineWidth = bodyRadius * 2 + 6
            strokeSmoothPath(path)

            ctx.strokeStyle = baseColor
            ctx.lineWidth = bodyRadius * 2
            ctx.shadowColor = withAlpha(baseColor, 0.45)
            ctx.shadowBlur = bodyRadius * 0.9
            strokeSmoothPath(path)

            ctx.shadowBlur = 0
            ctx.shadowColor = 'transparent'
            const highlight = path.slice(Math.max(0, path.length - 18))
            if (highlight.length >= 2) {
                ctx.globalAlpha = 0.55
                ctx.strokeStyle = withAlpha('#ffffff', 0.2)
                ctx.lineWidth = bodyRadius * 0.58
                strokeSmoothPath(highlight)
                ctx.globalAlpha = 1
            }

            const headGradient = ctx.createRadialGradient(head.x, head.y, headRadius * 0.2, head.x, head.y, headRadius * 1.4)
            headGradient.addColorStop(0, '#ffffff')
            headGradient.addColorStop(0.22, baseColor)
            headGradient.addColorStop(1, shadeColor(baseColor, -0.4))
            ctx.fillStyle = headGradient
            ctx.beginPath()
            ctx.arc(head.x, head.y, headRadius, 0, Math.PI * 2)
            ctx.fill()

            const dir = typeof snake.displayDir === 'number' ? snake.displayDir : snake.targetDir || 0
            const eyeOffset = headRadius * 0.58
            const sideOffset = headRadius * 0.32
            const pupilOffset = headRadius * 0.18
            const eyeRadius = headRadius * 0.28
            const pupilRadius = headRadius * 0.16
            const ex1 = head.x + Math.cos(dir) * eyeOffset - Math.sin(dir) * sideOffset
            const ey1 = head.y + Math.sin(dir) * eyeOffset + Math.cos(dir) * sideOffset
            const ex2 = head.x + Math.cos(dir) * eyeOffset + Math.sin(dir) * sideOffset
            const ey2 = head.y + Math.sin(dir) * eyeOffset - Math.cos(dir) * sideOffset
            ctx.fillStyle = '#f8fafc'
            ctx.beginPath(); ctx.arc(ex1, ey1, eyeRadius, 0, Math.PI * 2); ctx.fill()
            ctx.beginPath(); ctx.arc(ex2, ey2, eyeRadius, 0, Math.PI * 2); ctx.fill()
            ctx.fillStyle = '#0f172a'
            ctx.beginPath(); ctx.arc(ex1 + Math.cos(dir) * pupilOffset, ey1 + Math.sin(dir) * pupilOffset, pupilRadius, 0, Math.PI * 2); ctx.fill()
            ctx.beginPath(); ctx.arc(ex2 + Math.cos(dir) * pupilOffset, ey2 + Math.sin(dir) * pupilOffset, pupilRadius, 0, Math.PI * 2); ctx.fill()

            if (snake.name) {
                ctx.fillStyle = 'rgba(226, 232, 240, 0.9)'
                ctx.font = '600 13px "Inter", sans-serif'
                ctx.textAlign = 'center'
                ctx.textBaseline = 'bottom'
                ctx.fillText(snake.name, head.x, head.y - headRadius - 10)
            }
        }
        ctx.shadowBlur = 0
        ctx.shadowColor = 'transparent'
        ctx.restore()
    }

    function drawMinimap() {
        if (!minimapCtx) return
        minimapCtx.setTransform(DPR, 0, 0, DPR, 0, 0)
        const width = minimapCanvas.width / DPR
        const height = minimapCanvas.height / DPR
        minimapCtx.clearRect(0, 0, width, height)
        if (!state.world) return
        const cx = width / 2
        const cy = height / 2
        const mapRadius = Math.min(width, height) * 0.46
        const scale = mapRadius / state.world.radius
        const centerX = state.world.centerX
        const centerY = state.world.centerY

        minimapCtx.save()
        minimapCtx.fillStyle = 'rgba(11, 18, 30, 0.92)'
        minimapCtx.beginPath()
        minimapCtx.arc(cx, cy, mapRadius, 0, Math.PI * 2)
        minimapCtx.fill()
        minimapCtx.lineWidth = Math.max(1.2, mapRadius * 0.05)
        minimapCtx.strokeStyle = 'rgba(94, 117, 151, 0.45)'
        minimapCtx.stroke()
        minimapCtx.lineWidth = Math.max(0.8, mapRadius * 0.02)
        minimapCtx.strokeStyle = 'rgba(59, 130, 246, 0.35)'
        minimapCtx.beginPath()
        minimapCtx.arc(cx, cy, mapRadius - minimapCtx.lineWidth * 1.4, 0, Math.PI * 2)
        minimapCtx.stroke()
        minimapCtx.restore()

        minimapCtx.save()
        minimapCtx.beginPath()
        minimapCtx.arc(cx, cy, mapRadius - Math.max(2, mapRadius * 0.08), 0, Math.PI * 2)
        minimapCtx.clip()

        minimapCtx.globalAlpha = 0.9
        for (const food of state.foods.values()) {
            const fx = cx + (((typeof food.displayX === 'number' ? food.displayX : food.targetX) || centerX) - centerX) * scale
            const fy = cy + (((typeof food.displayY === 'number' ? food.displayY : food.targetY) || centerY) - centerY) * scale
            const radius = Math.max(2.2, 2.3 + Math.pow(Math.max(food.value || 1, 1), 0.32) * (food.big ? 1.5 : 1))
            minimapCtx.fillStyle = food.color || '#ffd166'
            minimapCtx.beginPath()
            minimapCtx.arc(fx, fy, radius, 0, Math.PI * 2)
            minimapCtx.fill()
        }

        minimapCtx.globalAlpha = 1
        const snakes = Array.from(state.snakes.values()).filter((s) => s.alive)
        snakes.sort((a, b) => (a.displayLength || a.length || 0) - (b.displayLength || b.length || 0))
        for (const snake of snakes) {
            const colors = SKINS[snake.skin] || SKINS.default
            const baseColor = colors[0] || '#94a3b8'
            const hx = cx + (((typeof snake.displayX === 'number' ? snake.displayX : snake.targetX) || centerX) - centerX) * scale
            const hy = cy + (((typeof snake.displayY === 'number' ? snake.displayY : snake.targetY) || centerY) - centerY) * scale
            const headSize = Math.max(3, Math.pow(Math.max(snake.displayLength || snake.length || 20, 20), 0.27) * 0.6)
            const path = snake.renderPath
            if (path && path.length > 1) {
                minimapCtx.beginPath()
                const first = path[0]
                minimapCtx.moveTo(cx + (first.x - centerX) * scale, cy + (first.y - centerY) * scale)
                const step = Math.max(1, Math.floor(path.length / 24))
                for (let i = step; i < path.length; i += step) {
                    const point = path[i]
                    minimapCtx.lineTo(cx + (point.x - centerX) * scale, cy + (point.y - centerY) * scale)
                }
                const tail = path[path.length - 1]
                minimapCtx.lineTo(cx + (tail.x - centerX) * scale, cy + (tail.y - centerY) * scale)
                minimapCtx.lineWidth = Math.max(1.2, headSize * 0.75)
                minimapCtx.strokeStyle = withAlpha(baseColor, snake.id === state.meId ? 0.95 : 0.6)
                minimapCtx.lineJoin = 'round'
                minimapCtx.lineCap = 'round'
                minimapCtx.stroke()
            }
            minimapCtx.fillStyle = baseColor
            minimapCtx.beginPath()
            minimapCtx.arc(hx, hy, headSize, 0, Math.PI * 2)
            minimapCtx.fill()
            if (snake.id === state.meId) {
                minimapCtx.lineWidth = Math.max(1.6, headSize * 0.6)
                minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)'
                minimapCtx.beginPath()
                minimapCtx.arc(hx, hy, headSize + minimapCtx.lineWidth * 0.4, 0, Math.PI * 2)
                minimapCtx.stroke()
            }
        }
        minimapCtx.restore()
    }

    function strokeSmoothPath(points) {
        if (!points || points.length < 2) return
        ctx.beginPath()
        ctx.moveTo(points[0].x, points[0].y)
        if (points.length === 2) {
            ctx.lineTo(points[1].x, points[1].y)
        } else {
            for (let i = 1; i < points.length - 1; i++) {
                const current = points[i]
                const next = points[i + 1]
                const midX = (current.x + next.x) / 2
                const midY = (current.y + next.y) / 2
                ctx.quadraticCurveTo(current.x, current.y, midX, midY)
            }
            const penultimate = points[points.length - 2]
            const last = points[points.length - 1]
            ctx.quadraticCurveTo(penultimate.x, penultimate.y, last.x, last.y)
        }
        ctx.stroke()
    }

    let lastTime = performance.now()
    function loop(now) {
        const dt = Math.min(0.05, (now - lastTime) / 1000)
        lastTime = now
        update(dt)
        draw(now / 1000)
        requestAnimationFrame(loop)
    }
    requestAnimationFrame(loop)

    function sendInput() {
        if (!ws || ws.readyState !== WebSocket.OPEN || !state.alive) return
        const boostStatus = refreshBoostState()
        const payload = { type: 'input', boost: boostStatus.active }
        if (typeof state.pointerAngle === 'number' && !Number.isNaN(state.pointerAngle)) {
            payload.angle = state.pointerAngle
        }
        ws.send(JSON.stringify(payload))
    }

    setInterval(sendInput, 30)

    function isEditableTarget(target) {
        if (!target) return false
        if (target.isContentEditable) return true
        const tag = target.tagName ? target.tagName.toUpperCase() : ''
        return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON'
    }

    function updatePointerFromTouch(touch) {
        if (!touch) return
        const rect = canvas.getBoundingClientRect()
        const cx = rect.left + rect.width / 2
        const cy = rect.top + rect.height / 2
        state.pointerAngle = Math.atan2(touch.clientY - cy, touch.clientX - cx)
    }

    document.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect()
        const cx = rect.left + rect.width / 2
        const cy = rect.top + rect.height / 2
        const angle = Math.atan2(event.clientY - cy, event.clientX - cx)

        if (typeof state.pointerAngle === 'number') {
            let diff = angle - state.pointerAngle
            while (diff < -Math.PI) diff += Math.PI * 2
            while (diff > Math.PI) diff -= Math.PI * 2
            state.pointerAngle += diff
        } else {
            state.pointerAngle = angle
        }
    })

    document.addEventListener('mousedown', (event) => {
        if (event.button !== 0) return
        if (isEditableTarget(event.target)) return
        if (event.target && event.target.closest('.touch-controls')) return
        setBoostIntent(true)
    })

    document.addEventListener('mouseup', () => {
        resetBoostIntent()
    })

    window.addEventListener('blur', () => {
        resetBoostIntent()
        joystickActive = false
        resetJoystickHandle()
        resetCashoutHold()
    })

    canvas.addEventListener('touchstart', (event) => {
        if (touchControlsEnabled) return
        if (!event.touches || !event.touches.length) return
        updatePointerFromTouch(event.touches[0])
        setBoostIntent(event.touches.length > 1)
        event.preventDefault()
    }, { passive: false })

    canvas.addEventListener('touchmove', (event) => {
        if (touchControlsEnabled) return
        if (!event.touches || !event.touches.length) return
        updatePointerFromTouch(event.touches[0])
        setBoostIntent(event.touches.length > 1)
        event.preventDefault()
    }, { passive: false })

    canvas.addEventListener('touchend', (event) => {
        if (touchControlsEnabled) return
        if (!event.touches || event.touches.length === 0) {
            resetBoostIntent()
        } else {
            setBoostIntent(event.touches.length > 1)
        }
    })

    canvas.addEventListener('touchcancel', () => {
        if (touchControlsEnabled) return
        resetBoostIntent()
    })

    if (joystick) {
        joystick.addEventListener('pointerdown', (event) => {
            if (!touchControlsEnabled) return
            joystickActive = true
            if (typeof joystick.setPointerCapture === 'function') {
                try { joystick.setPointerCapture(event.pointerId) } catch (err) { /* ignore */ }
            }
            updateJoystickPosition(event.clientX, event.clientY)
            event.preventDefault()
        })

        joystick.addEventListener('pointermove', (event) => {
            if (!joystickActive) return
            updateJoystickPosition(event.clientX, event.clientY)
            event.preventDefault()
        })

        const finishJoystick = () => {
            joystickActive = false
            resetJoystickHandle()
        }

        joystick.addEventListener('pointerup', finishJoystick)
        joystick.addEventListener('pointercancel', finishJoystick)
        joystick.addEventListener('lostpointercapture', finishJoystick)
    }

    if (boostButton) {
        const startBoost = (event) => {
            event.preventDefault()
            if (boostButton.disabled) return
            setBoostIntent(true)
        }
        const stopBoost = (event) => {
            event.preventDefault()
            resetBoostIntent()
        }
        boostButton.addEventListener('pointerdown', startBoost)
        boostButton.addEventListener('pointerup', stopBoost)
        boostButton.addEventListener('pointerleave', stopBoost)
        boostButton.addEventListener('pointercancel', stopBoost)
        boostButton.addEventListener('keydown', (event) => {
            if (event.code === 'Space' || event.key === ' ' || event.key === 'Enter') {
                event.preventDefault()
                setBoostIntent(true)
            }
        })
        boostButton.addEventListener('keyup', (event) => {
            if (event.code === 'Space' || event.key === ' ' || event.key === 'Enter') {
                event.preventDefault()
                resetBoostIntent()
            }
        })
    }

    if (cashoutButton) {
        cashoutButton.addEventListener('pointerdown', (event) => {
            if (event.button !== undefined && event.button !== 0) return
            if (cashoutButton.disabled || cashoutButton.getAttribute('aria-disabled') === 'true') return
            event.preventDefault()
            startCashoutHold('pointer')
        })
        const stopCashoutPointer = () => {
            if (!cashoutPending) {
                resetCashoutHold()
            }
        }
        cashoutButton.addEventListener('pointerup', stopCashoutPointer)
        cashoutButton.addEventListener('pointerleave', stopCashoutPointer)
        cashoutButton.addEventListener('pointercancel', stopCashoutPointer)
    }

    window.addEventListener('keydown', (event) => {
        if (event.repeat) return
        if (event.code === 'Space') {
            if (isEditableTarget(event.target)) return
            event.preventDefault()
            setBoostIntent(true)
        }
        if (event.code === 'KeyQ' || event.key === 'q' || event.key === 'Q') {
            if (isEditableTarget(event.target)) return
            event.preventDefault()
            startCashoutHold('keyboard')
        }
    })

    window.addEventListener('keyup', (event) => {
        if (event.code === 'Space') {
            resetBoostIntent()
        }
        if (event.code === 'KeyQ' || event.key === 'q' || event.key === 'Q') {
            if (!cashoutPending) {
                resetCashoutHold()
            }
        }
    })

    if (betInput) {
        betInput.addEventListener('blur', () => {
            const balance = Math.max(0, state.account.balance || 0)
            if (balance <= 0) {
                betInput.value = ''
                return
            }
            const sanitized = sanitizeBetValue(betInput.value, balance)
            betInput.value = sanitized > 0 ? sanitized : ''
        })
    }

    if (retryBetInput) {
        retryBetInput.addEventListener('blur', () => {
            const balance = Math.max(0, state.account.balance || 0)
            if (balance <= 0) {
                retryBetInput.value = ''
                return
            }
            const sanitized = sanitizeBetValue(retryBetInput.value, balance)
            retryBetInput.value = sanitized > 0 ? sanitized : ''
        })
    }

    function startGame() {
        const name = nicknameInput.value.trim() || 'Anon'
        const balanceForBet = state.account.balance || 0
        let betAmount = betInput ? sanitizeBetValue(betInput.value, balanceForBet) : 0
        if (betInput) {
            if (betAmount > 0) {
                betInput.value = betAmount
            } else {
                betInput.value = balanceForBet > 0 ? 1 : ''
            }
        }
        state.pendingBet = betAmount > 0 ? betAmount : null
        state.meName = name
        nicknameScreen.classList.add('hidden')
        connect(name, selectedSkin)
    }

    startBtn.addEventListener('click', startGame)
    nicknameInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') startGame()
    })

    if (cashoutCloseBtn) {
        cashoutCloseBtn.addEventListener('click', () => {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.close(1000, 'client_exit')
                }
            } catch (err) {
                // ignore
            }
            window.location.reload()
        })
    }
})();
</script>
</body>
</html>
